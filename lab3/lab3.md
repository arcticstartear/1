# lab3

## 练习一：

### 描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？（为了方便同学们完成练习，所以实际上我们的项目代码和实验指导的还是略有不同，例如我们将FIFO页面置换算法头文件的大部分代码放在了kern/mm/swap_fifo.c文件中，这点请同学们注意）至少正确指出10个不同的函数分别做了什么？如果少于10个将酌情给分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响,删去后会导致输出结果不同的函数（例如assert）而不是cprintf这样的函数。如果你选择的函数不能完整地体现”从换入到换出“的过程，比如10个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这10个函数在页面换入时的功能，那么也会扣除一定的分数

答：FIFO页面置换算法下，一个页面从被换入到被换出的过程中需要调用以下函数：
1. _fifo_init_mm()：初始化pra_list_head并将mm->sm_priv指向pra_list_head的地址，使得从内存控制结构mm_struct可以访问FIFO页面置换算法；
2. _fifo_map_swappable()：将最近到达的页面链接到pra_list_head队列的末尾；
3. list_add()：将页面添加到双向链表中；
4. _fifo_swap_out_victim()：选择一个牺牲页，即在pra_list_head队列前面的页面，并将该页面的地址设置为ptr_page；
5. list_prev()：返回给定元素的前一个元素；
6. list_del()：从双向链表中删除给定元素；
7. le2page()：将通用链表结构转换为特定结构，即将list_entry_t转换为struct Page；
8. assert()：当断言条件不满足时，终止程序并输出错误信息；
9. _fifo_check_swap()：检查FIFO页面置换算法是否正确执行；
10. *(unsigned char *)：将指定地址的值作为字符读取或写入；

具体来说，页面从被换入到被换出的过程中

首先通过_fifo_init_mm()初始化pra_list_head并将mm->sm_priv指向pra_list_head的地址，使得可以访问FIFO页面置换算法；

然后通过_fifo_map_swappable()将最近到达的页面链接到pra_list_head队列的末尾，使用list_add()将页面添加到双向链表中；

当需要选择一个牺牲页时，通过_fifo_swap_out_victim()选择在pra_list_head队列前面的页面，并将该页面的地址设置为ptr_page。在这个过程中，使用list_prev()返回给定元素的前一个元素，使用list_del()从双向链表中删除给定元素。同时，使用le2page()将通用链表结构转换为特定结构，将list_entry_t转换为struct Page；

如果出现错误，则使用assert()终止程序并输出错误信息；

最后，通过_fifo_check_swap()检查FIFO页面置换算法是否正确执行，并使用*(unsigned char *)将指定地址的值作为字符读取或写入。

## 练习二： 

### get_pte()函数（位于kern/mm/pmm.c）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
### ·get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像？
### ·目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

·这两段代码的相似性来自于它们都是用于处理不同分页模式下的页表项查找和分配操作。在sv32、sv39、sv48这三种分页模式下，页表结构和访问方式有一定的相似性，因此可以通过共享相同的代码来实现类似的功能。具体来说，这两段代码都是先检查页表项是否存在，如果不存在则分配一个物理页，并将页表项与之关联；

·将页表项的查找和页表项的分配合并在一个函数中是一种较好的设计选择；

如果将这两个功能拆开，可能会导致代码冗余和重复，增加代码量和维护成本；同时，将它们合并在一个函数中可以减少函数调用的开销，提高整体的执行效率，因此没有必要拆开；

## 练习三： 

### 补充完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。 请在实验报告中简要说明你的设计实现过程。

```
if (swap_init_ok) {
    struct Page *page = NULL;
    ret = swap_in(mm, addr, &page);
    page_insert(mm->pgdir,page,addr,perm);
    swap_map_swappable(mm,addr,page,1);
    page->pra_vaddr = addr;
}
```

pte是一个交换条目，应该从磁盘加载数据并放到带有phy addr的页面，并将phy addr与逻辑addr映射，触发交换管理器记录该页面的访问情况

swap_in(mm, addr, &page) : 分配一个内存页，然后根据PTE中的swap条目的addr，找到磁盘页的地址，将磁盘页的内容读入这个内存页

page_insert ： 建立一个Page的phy addr与线性addr la的映射

swap_map_swappable ： 设置页面可交换

### 请回答如下问题：
### 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。

在ucore中，页目录项（Page Directory Entry）和页表项（Page Table Entry）是用来描述虚拟地址与物理地址映射关系的数据结构。它们对于实现页替换算法有以下潜在用处：
1. 访问位（Accessed Bit）：页表项中的访问位可以用来记录页面是否被访问过。当发生页面访问异常时，可以根据访问位的状态来判断页面是否被访问过，从而决定是否需要进行页面替换；
2. 修改位（Dirty Bit）：页表项中的修改位可以用来记录页面是否被修改过。当发生页面访问异常时，可以根据修改位的状态来判断页面是否被修改过，从而决定是否需要将页面写回磁盘或者进行其他处理；
3. 保护位（Protection Bit）：页表项中的保护位可以用来指定页面的访问权限，如读、写、执行等。在进行页面替换时，可以根据保护位来判断是否需要更新页面的权限信息；
4. 其他标志位：页目录项和页表项中可能还包含其他的标志位，如有效位（Valid Bit）、全局位（Global Bit）等，这些标志位也可以用于实现页替换算法的相关逻辑。

### 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

对于ucore的缺页服务例程，在执行过程中如果出现了页访问异常，硬件需要进行以下操作：
1. 保存当前的程序状态：硬件需要将当前的程序状态（如寄存器的值、指令指针等）保存起来，以便后续恢复执行；
2. 触发异常处理流程：硬件会跳转到预先定义的异常处理例程，并将控制权交给操作系统内核；
3. 由操作系统处理异常：操作系统内核会根据异常类型（如缺页异常）进行相应的处理，可能包括页面调度、页面替换等操作。

### 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

关于数据结构Page的全局变量和页表中的页目录项和页表项的对应关系，在ucore中存在对应关系。具体来说，Page的全局变量数组中的每一项与页表中的页目录项和页表项是一一对应的。Page的全局变量数组中的每一项表示一个物理页面，而页目录项和页表项中的地址字段则指向对应的物理页面。这种对应关系可以用来进行页面分配、管理和访问等操作。

## 练习四：

### 通过之前的练习，相信大家对FIFO的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 Clock页替换算法（mm/swap_clock.c）。 请在实验报告中简要说明你的设计实现过程。

```
static int
_clock_init_mm(struct mm_struct *mm)
{
     list_init(&pra_list_head);
     curr_ptr = &pra_list_head;
     mm->sm_priv = &pra_list_head;
     return 0;
}
```

初始化pra_list_head为空链表

初始化当前指针curr_ptr指向pra_list_head，表示当前页面替换位置为链表头

将mm的私有成员指针指向pra_list_head，用于后续的页面替换算法操作

```
static int
_clock_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
{
    list_entry_t *entry=&(page->pra_page_link);
 
    assert(entry != NULL && curr_ptr != NULL);
    list_entry_t *head=(list_entry_t*) mm->sm_priv;
    list_add_before(head,entry);
    page->visited = 1;
    return 0;
}
```

将页面page插入到页面链表pra_list_head的末尾

将页面的visited标志置为1，表示该页面已被访问

```
static int
_clock_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)
{
     list_entry_t *head=(list_entry_t*) mm->sm_priv;
         assert(head != NULL);
     assert(in_tick==0);
    while (1) {
        if(curr_ptr == head) {
            curr_ptr = list_next(curr_ptr);
            continue;
        }
        struct Page * page = le2page(curr_ptr,pra_page_link);
        list_entry_t* next_entry = list_next(curr_ptr);
        if(page->visited == 0) {
            cprintf("curr_ptr 0xffffffff%x\n",curr_ptr);
            list_del(curr_ptr);
            *ptr_page = page;
            curr_ptr = next_entry;
            break;
        } else {
            page->visited = 0;
            curr_ptr = list_next(curr_ptr);
        }
    }
    return 0;
}
```

遍历页面链表pra_list_head，查找最早未被访问的页面

获取当前页面对应的Page结构指针

如果当前页面未被访问，则将该页面从页面链表中删除，并将该页面指针赋值给ptr_page作为换出页面

如果当前页面已被访问，则将visited标志置为0，表示该页面已被重新访问

### 请回答如下问题：

### 比较Clock页替换算法和FIFO算法的不同。

Clock页替换算法和FIFO（First-In-First-Out）算法是两种常见的页面替换算法，它们在实现上有一些不同之处：
1. 工作方式：

    FIFO算法：按照页面进入内存的顺序进行替换，即最早进入内存的页面会被替换出去，使用一个队列来维护页面的进入顺序。
    
    Clock算法：基于时钟指针的方式进行替换。它维护一个环形链表，每个节点表示一个页面，并使用一个指针来指向当前位置。当需要进行替换时，时钟指针按照顺时针方向移动，找到一个未被访问的页面进行替换；
2. 页面访问记录：

    FIFO算法：不记录页面的访问情况，只根据页面的进入顺序进行替换；
    
    Clock算法：使用访问位（Accessed Bit）来记录页面是否被访问过。当页面被访问时，访问位被设置为1；当需要进行替换时，时钟指针按顺时针方向查找第一个访问位为0的页面进行替换，并将访问位设为0；
3. 算法复杂度：

    FIFO算法：简单直观，但没有考虑页面的访问情况，可能导致频繁访问的页面被替换出去；
    
    Clock算法：通过使用访问位来考虑页面的访问情况，可以相对较好地保留经常访问的页面，提高替换效率；
4. 实现开销：

    FIFO算法：只需要一个队列来维护页面的进入顺序，实现相对简单；
    
    Clock算法：需要维护一个环形链表和访问位，并进行时钟指针的移动，实现相对复杂一些；
    
总体而言，FIFO算法是一种简单且容易实现的页面替换算法，但可能无法充分考虑页面的访问情况。相比之下，Clock算法通过使用访问位来考虑页面的访问情况，可以更好地保留经常访问的页面，提高替换效率。

## 练习五：

### 如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？

### 好处：
1. 减少页表项数量：使用大页可以减少页表项的数量，因为一个大页可以映射更多的虚拟地址空间。这样可以减少页表的大小，节省内存空间。
2. 提高TLB命中率：由于大页可以映射更多的虚拟地址空间，因此在访问连续的虚拟地址时，大页能够提供更高的TLB（Translation Lookaside Buffer）命中率。TLB是存储最近访问的页表项的高速缓存，高命中率可以提高访问效率。
3. 减少页表访问开销：使用大页可以减少对页表的访问次数，因为一个大页可以覆盖更多的虚拟地址范围。这样可以减少页表访问的开销，提高内存访问效率。
### 坏处：
1. **内存碎片问题**：使用大页会增加内存碎片的风险。由于大页的大小通常比较大，如果没有足够连续的物理内存来分配大页，就会导致内存碎片问题。这可能影响内存的利用率和性能。
2. 预分配开销：为了使用大页，操作系统需要预先分配足够的连续物理内存来满足大页的需求。这可能会增加系统启动时的开销，并且在系统运行过程中，可能会导致内存分配的复杂性和开销。
3. 灵活性受限：使用大页会降低对内存映射的灵活性。由于大页的大小固定，无法根据不同的内存访问模式和需求进行灵活调整。这可能导致一些特定应用场景下的性能损失。

## 思考：

### 关于Belady现象：

Belady现象是指在FIFO算法进行页面置换背景下，当内存空间有限且页面访问模式不断变化时，可能会发生更多的页面错误，如缺页中断等；

这是因为FIFO算法只考虑了页面进入内存的顺序，而没有考虑页面的访问频率以及重要性。当页面访问模式发生变化时，如果之前被淘汰的页面突然变得频繁访问，那么增加物理页面帧数可能无法改善页面错误率；

为了解决这个问题，可以采用其他更高级的页面置换算法，如LRU算法或者OPT算法，其考虑了页面的访问历史或未来访问模式，能够更有效地减少页面错误的数量。
